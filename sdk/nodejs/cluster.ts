// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Manages [clusters](https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#clusters) within ArgoCD.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as argocd from "@three14/pulumi-argocd";
 * import * as aws from "@pulumi/aws";
 * import * as gcp from "@pulumi/gcp";
 * import * as kubernetes from "@pulumi/kubernetes";
 * import * as std from "@pulumi/std";
 *
 * //# Bearer token Authentication
 * const kubernetes = new argocd.Cluster("kubernetes", {
 *     server: "https://1.2.3.4:12345",
 *     config: {
 *         bearerToken: "eyJhbGciOiJSUzI...",
 *         tlsClientConfig: {
 *             caData: std.file({
 *                 input: "path/to/ca.pem",
 *             }).then(invoke => invoke.result),
 *         },
 *     },
 * });
 * //# GCP GKE cluster
 * const cluster = gcp.container.getCluster({
 *     name: "cluster",
 *     location: "europe-west1",
 * });
 * const argocdManager = new kubernetes.core.v1.ServiceAccount("argocd_manager", {metadata: {
 *     name: "argocd-manager",
 *     namespace: "kube-system",
 * }});
 * const argocdManagerClusterRole = new kubernetes.rbac.v1.ClusterRole("argocd_manager", {
 *     metadata: {
 *         name: "argocd-manager-role",
 *     },
 *     rules: [
 *         {
 *             apiGroups: ["*"],
 *             resources: ["*"],
 *             verbs: ["*"],
 *         },
 *         {
 *             nonResourceUrls: ["*"],
 *             verbs: ["*"],
 *         },
 *     ],
 * });
 * const argocdManagerClusterRoleBinding = new kubernetes.rbac.v1.ClusterRoleBinding("argocd_manager", {
 *     metadata: {
 *         name: "argocd-manager-role-binding",
 *     },
 *     roleRef: {
 *         apiGroup: "rbac.authorization.k8s.io",
 *         kind: "ClusterRole",
 *         name: argocdManagerClusterRole.metadata.apply(metadata => metadata.name),
 *     },
 *     subjects: [{
 *         kind: "ServiceAccount",
 *         name: argocdManager.metadata.apply(metadata => metadata.name),
 *         namespace: argocdManager.metadata.apply(metadata => metadata.namespace),
 *     }],
 * });
 * const argocdManagerSecret = new kubernetes.core.v1.Secret("argocd_manager", {metadata: {
 *     name: argocdManager.defaultSecretName,
 *     namespace: argocdManager.metadata.apply(metadata => metadata.namespace),
 * }});
 * const gke = new argocd.Cluster("gke", {
 *     server: cluster.then(cluster => std.join({
 *         separator: "",
 *         input: [
 *             "https://%s",
 *             cluster.endpoint,
 *         ],
 *     })).then(invoke => invoke.result),
 *     name: "gke",
 *     config: {
 *         bearerToken: argocdManagerKubernetesSecret.data.token,
 *         tlsClientConfig: {
 *             caData: cluster.then(cluster => std.base64decode({
 *                 input: cluster.masterAuths?.[0]?.clusterCaCertificate,
 *             })).then(invoke => invoke.result),
 *         },
 *     },
 * });
 * //# AWS EKS cluster
 * const clusterGetCluster = aws.eks.getCluster({
 *     name: "cluster",
 * });
 * const eks = new argocd.Cluster("eks", {
 *     server: clusterGetCluster.then(clusterGetCluster => std.join({
 *         separator: "",
 *         input: [
 *             "https://%s",
 *             clusterGetCluster.endpoint,
 *         ],
 *     })).then(invoke => invoke.result),
 *     name: "eks",
 *     namespaces: [
 *         "default",
 *         "optional",
 *     ],
 *     config: {
 *         awsAuthConfigs: [{
 *             clusterName: "myekscluster",
 *             roleArn: "arn:aws:iam::<123456789012>:role/<role-name>",
 *         }],
 *         tlsClientConfig: {
 *             caData: clusterGetCluster.then(clusterGetCluster => std.base64decode({
 *                 input: clusterGetCluster.certificateAuthorities?.[0]?.data,
 *             })).then(invoke => invoke.result),
 *         },
 *     },
 * });
 * ```
 *
 * ## Import
 *
 * Cluster credentials can be imported using the server URL.
 *
 * Example:
 *
 * ```sh
 * $ pulumi import argocd:index/cluster:Cluster mycluster https://mycluster.io:443
 * ```
 */
export class Cluster extends pulumi.CustomResource {
  /**
   * Get an existing Cluster resource's state with the given name, ID, and optional extra
   * properties used to qualify the lookup.
   *
   * @param name The _unique_ name of the resulting resource.
   * @param id The _unique_ provider ID of the resource to lookup.
   * @param state Any extra arguments used during the lookup.
   * @param opts Optional settings to control the behavior of the CustomResource.
   */
  public static get(
    name: string,
    id: pulumi.Input<pulumi.ID>,
    state?: ClusterState,
    opts?: pulumi.CustomResourceOptions
  ): Cluster {
    return new Cluster(name, <any>state, { ...opts, id: id });
  }

  /** @internal */
  public static readonly __pulumiType = "argocd:index/cluster:Cluster";

  /**
   * Returns true if the given object is an instance of Cluster.  This is designed to work even
   * when multiple copies of the Pulumi SDK have been loaded into the same process.
   */
  public static isInstance(obj: any): obj is Cluster {
    if (obj === undefined || obj === null) {
      return false;
    }
    return obj["__pulumiType"] === Cluster.__pulumiType;
  }

  /**
   * Cluster information for connecting to a cluster.
   */
  public readonly config!: pulumi.Output<outputs.ClusterConfig>;
  /**
   * Information about cluster cache and state.
   */
  public readonly /*out*/ infos!: pulumi.Output<outputs.ClusterInfo[]>;
  /**
   * Standard cluster secret's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  public readonly metadatas!: pulumi.Output<
    outputs.ClusterMetadata[] | undefined
  >;
  /**
   * Name of the cluster. If omitted, will use the server address.
   */
  public readonly name!: pulumi.Output<string>;
  /**
   * List of namespaces which are accessible in that cluster. Cluster level resources would be ignored if namespace list is not empty.
   */
  public readonly namespaces!: pulumi.Output<string[] | undefined>;
  /**
   * Reference between project and cluster that allow you automatically to be added as item inside Destinations project entity. More info: https://argo-cd.readthedocs.io/en/stable/user-guide/projects/#project-scoped-repositories-and-clusters.
   */
  public readonly project!: pulumi.Output<string | undefined>;
  /**
   * Server is the API server URL of the Kubernetes cluster.
   */
  public readonly server!: pulumi.Output<string | undefined>;
  /**
   * Optional shard number. Calculated on the fly by the application controller if not specified.
   */
  public readonly shard!: pulumi.Output<string | undefined>;

  /**
   * Create a Cluster resource with the given unique name, arguments, and options.
   *
   * @param name The _unique_ name of the resource.
   * @param args The arguments to use to populate this resource's properties.
   * @param opts A bag of options that control this resource's behavior.
   */
  constructor(
    name: string,
    args: ClusterArgs,
    opts?: pulumi.CustomResourceOptions
  );
  constructor(
    name: string,
    argsOrState?: ClusterArgs | ClusterState,
    opts?: pulumi.CustomResourceOptions
  ) {
    let resourceInputs: pulumi.Inputs = {};
    opts = opts || {};
    if (opts.id) {
      const state = argsOrState as ClusterState | undefined;
      resourceInputs["config"] = state ? state.config : undefined;
      resourceInputs["infos"] = state ? state.infos : undefined;
      resourceInputs["metadatas"] = state ? state.metadatas : undefined;
      resourceInputs["name"] = state ? state.name : undefined;
      resourceInputs["namespaces"] = state ? state.namespaces : undefined;
      resourceInputs["project"] = state ? state.project : undefined;
      resourceInputs["server"] = state ? state.server : undefined;
      resourceInputs["shard"] = state ? state.shard : undefined;
    } else {
      const args = argsOrState as ClusterArgs | undefined;
      if ((!args || args.config === undefined) && !opts.urn) {
        throw new Error("Missing required property 'config'");
      }
      resourceInputs["config"] = args ? args.config : undefined;
      resourceInputs["metadatas"] = args ? args.metadatas : undefined;
      resourceInputs["name"] = args ? args.name : undefined;
      resourceInputs["namespaces"] = args ? args.namespaces : undefined;
      resourceInputs["project"] = args ? args.project : undefined;
      resourceInputs["server"] = args ? args.server : undefined;
      resourceInputs["shard"] = args ? args.shard : undefined;
      resourceInputs["infos"] = undefined /*out*/;
    }
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
    super(Cluster.__pulumiType, name, resourceInputs, opts);
  }
}

/**
 * Input properties used for looking up and filtering Cluster resources.
 */
export interface ClusterState {
  /**
   * Cluster information for connecting to a cluster.
   */
  config?: pulumi.Input<inputs.ClusterConfig>;
  /**
   * Information about cluster cache and state.
   */
  infos?: pulumi.Input<pulumi.Input<inputs.ClusterInfo>[]>;
  /**
   * Standard cluster secret's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  metadatas?: pulumi.Input<pulumi.Input<inputs.ClusterMetadata>[]>;
  /**
   * Name of the cluster. If omitted, will use the server address.
   */
  name?: pulumi.Input<string>;
  /**
   * List of namespaces which are accessible in that cluster. Cluster level resources would be ignored if namespace list is not empty.
   */
  namespaces?: pulumi.Input<pulumi.Input<string>[]>;
  /**
   * Reference between project and cluster that allow you automatically to be added as item inside Destinations project entity. More info: https://argo-cd.readthedocs.io/en/stable/user-guide/projects/#project-scoped-repositories-and-clusters.
   */
  project?: pulumi.Input<string>;
  /**
   * Server is the API server URL of the Kubernetes cluster.
   */
  server?: pulumi.Input<string>;
  /**
   * Optional shard number. Calculated on the fly by the application controller if not specified.
   */
  shard?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Cluster resource.
 */
export interface ClusterArgs {
  /**
   * Cluster information for connecting to a cluster.
   */
  config: pulumi.Input<inputs.ClusterConfig>;
  /**
   * Standard cluster secret's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
   */
  metadatas?: pulumi.Input<pulumi.Input<inputs.ClusterMetadata>[]>;
  /**
   * Name of the cluster. If omitted, will use the server address.
   */
  name?: pulumi.Input<string>;
  /**
   * List of namespaces which are accessible in that cluster. Cluster level resources would be ignored if namespace list is not empty.
   */
  namespaces?: pulumi.Input<pulumi.Input<string>[]>;
  /**
   * Reference between project and cluster that allow you automatically to be added as item inside Destinations project entity. More info: https://argo-cd.readthedocs.io/en/stable/user-guide/projects/#project-scoped-repositories-and-clusters.
   */
  project?: pulumi.Input<string>;
  /**
   * Server is the API server URL of the Kubernetes cluster.
   */
  server?: pulumi.Input<string>;
  /**
   * Optional shard number. Calculated on the fly by the application controller if not specified.
   */
  shard?: pulumi.Input<string>;
}
